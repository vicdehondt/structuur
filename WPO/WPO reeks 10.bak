(#%require "streams.rkt")

; Oef 10.1
(define (fac n)
  (if (<= n 1)
      1
      (* n (fac (- n 1)))))

(define (calc-e n)
  (let ((str (enumerate-interval 0 n)))
    (accumulate + 0 (map-stream (lambda (n) (/ 1 (fac n))) str))))

(define (sinus x n)
  (define (calc-term t)
    (* (if (odd? (/ (- t 1) 2)) -1 1)
       (/  (exp x t)
           (fac t))))
  (define (exp x n)
    (if (zero? n)
        1
        (* x (exp x (- n 1)))))
  (map-stream calc-term (streamfilter odd? (enumerate-interval 0 n))))



(define (exp x n)
  (if (zero? n)
      1
      (* x (exp x (- n 1)))))

; Oef 10.2
(define (sum-odd-squares str)
  (accumulate + 0 (map-stream (lambda (n) (* n n)) (streamfilter odd? str))))

; Oef 10.3
(define (odd-sum-triples max)
  (map-stream (lambda (x) (let ((l (car x))
                                (r (cdr x)))
                            (list )))))

; Oef 10.4
(define (fac n)
  (display "->")(display n)(newline)
  (if (= n 0)
      1
      (* n (fac (- n 1)))))

; Oef 10.5
(define (show x)
  (display x)(newline)
  x)

; Oef 10.7
(define integers (cons-stream 1 (map-stream (lambda (x) (+ x 1)) integers)))

; Oef 10.9
(define (triplets)
  (define (constraint lst)
    (let ((i (car lst))
          (j (cadr lst))
          (k (caddr lst)))
      (> (+ i j) k)))
  
  (streamfilter constraint
                (cartesian-product integers integers integers)))

; Oef 10.12
(define (cut s)
  (define (split result s)
    (cond
      ((empty-stream? s) (cons result the-empty-stream))
      ((eq? (head result) (head s)) (split (cons-stream (head s) result) (tail s)))
      (else (cons result s))))
  (if (empty-stream? s)
      the-empty-stream
      (let ((result (split (cons-stream (head s) the-empty-stream) (tail s))))
        (cons-stream (car result)
                     (cut (cdr result))))))

(define (merge s1 s2)
  (cond
    ((empty-stream? s1) s2)
    ((empty-stream? s2) s1)
    ((> (head s1) (head s2))
     (merge s2 s1))
    (else (cons-stream (head s1) (merge (tail s1) s2)))))

(define (merge-n s)
  (define (loop s1 s2)
    (cond
      ((empty-stream? s2) s1)
      ((empty-stream? (tail s2)) (merge s1 (head s2)))
      (else (merge (merge s1 (head s2)) (head (tail s2))))))
  (loop (head s) (tail s)))

(define (pretpark-traffiek s)
  (map-stream (lambda (x) (cons (head x)
                                (accumulate + 0 (map-stream (lambda (y) 1) x))))
              (cut (merge-n s))))
 
; Oef 10.16
(define (prune s n)
  (define (loop count end-point)
    (if (zero? end-point)
        ())))




